### 1. **동기화 문제 (Synchronization Issue)**  
멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 데이터 일관성이 깨지거나 예상치 못한 결과가 발생하는 문제를 의미합니다.  
- **예:** 두 스레드가 같은 변수 값을 읽고 동시에 값을 변경하면, 최종 값이 의도한 것과 다를 수 있음.
- **해결책:** 동기화 기법(예: `synchronized` 키워드, ReentrantLock 등)을 사용하여 스레드 간 자원 접근을 조정.

---

### 2. **데드락 (Deadlock)**  
두 개 이상의 스레드가 서로가 보유한 자원을 기다리면서 무한히 정지 상태에 빠지는 상황을 말합니다.  
- **발생 조건:**  
  1. 상호 배제 (Mutual Exclusion): 한 번에 한 스레드만 자원을 사용할 수 있음.  
  2. 점유와 대기 (Hold and Wait): 자원을 점유한 스레드가 다른 자원을 기다림.  
  3. 비선점 (No Preemption): 자원을 강제로 해제할 수 없음.  
  4. 순환 대기 (Circular Wait): 스레드들이 순환 구조로 자원을 기다림.
- **해결책:**  
  - 자원 순서를 정의해 순환 대기를 방지.
  - 타임아웃 설정을 통해 무한 대기 방지.

---

### 3. **레이스 컨디션 (Race Condition)**  
두 개 이상의 스레드가 동시에 실행되며 특정 실행 순서에 따라 결과가 달라지는 상황을 의미합니다.  
- **예:**  
  - 한 스레드가 변수를 읽는 동시에 다른 스레드가 해당 변수를 수정할 경우.  
- **해결책:**  
  - 동기화 블록 사용.
  - 불변 객체 사용.
  - 원자적 연산 (Atomic Operations) 사용.

---

### 4. **복잡한 애플리케이션 (Complex Application)**  
멀티스레딩과 같은 병렬 처리를 활용하는 애플리케이션은 여러 작업이 동시에 실행되므로 설계와 디버깅이 매우 복잡해질 수 있습니다.  
- **원인:**  
  - 스레드 간 상호작용 증가.
  - 자원 경합(Resource Contention) 문제.
  - 상태 관리 어려움.
- **해결책:**  
  - 적절한 동기화 도구 사용.
  - 스레드 풀 사용으로 스레드 관리 단순화.
  - 병렬 처리를 추상화한 프레임워크(예: Java의 Fork/Join Framework) 사용.

---

### 5. **메모리 오버헤드 (Memory Overhead)**  
스레드 생성 및 관리를 위해 추가적으로 소요되는 메모리와 리소스를 의미합니다.  
- **예:** 각 스레드가 독립적인 스택 메모리를 필요로 함. 스레드 수가 많아질수록 메모리 소모가 증가.  
- **해결책:**  
  - 스레드 풀을 사용해 스레드 생성을 재사용 가능하도록 제한.  
  - 필요 이상으로 많은 스레드 생성 회피.

---

### 6. **스레드 풀 (Thread Pool)**  
미리 정해진 수의 스레드를 생성하고 재사용하여 성능과 효율성을 높이는 기술입니다.  
- **작동 방식:**  
  1. 애플리케이션이 작업을 제출하면, 스레드 풀은 대기 중인 스레드에 작업을 할당.  
  2. 모든 스레드가 사용 중이면, 작업은 대기열(Queue)에 저장됨.  
  3. 작업 완료 시 스레드는 다시 풀로 돌아와 다른 작업을 처리.  
- **장점:**  
  - 스레드 생성/소멸 오버헤드 감소.  
  - 제한된 스레드 수로 자원 과다 사용 방지.  
  - 데드락 및 동기화 문제 감소.  
- **단점:**  
  - 풀 크기를 잘못 설정하면 성능 저하나 메모리 부족 문제가 발생.
