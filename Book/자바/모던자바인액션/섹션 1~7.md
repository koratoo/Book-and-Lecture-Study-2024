## 목차

### [PART I 기초](#part-i-기초)

### [CHAPTER 1 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?](#chapter-1-자바-8-9-10-11--무슨-일이-일어나고-있는가)

- [1.1 역사의 흐름은 무엇인가?](#11-역사의-흐름은-무엇인가)
- [1.2 왜 아직도 자바는 변화하는가?](#12-왜-아직도-자바는-변화하는가)
- [1.3 자바 함수](#13-자바-함수)
- [1.4 스트림](#14-스트림)
- [1.5 디폴트 메서드와 자바 모듈](#15-디폴트-메서드와-자바-모듈)
- [1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어](#16-함수형-프로그래밍에서-가져온-다른-유용한-아이디어)
- [1.7 마치며](#17-마치며)

### [CHAPTER 2 동작 파라미터화 코드 전달하기](#chapter-2-동작-파라미터화-코드-전달하기)

- [2.1 변화하는 요구사항에 대응하기](#21-변화하는-요구사항에-대응하기)
- [2.2 동작 파라미터화](#22-동작-파라미터화)
- [2.3 복잡한 과정 간소화](#23-복잡한-과정-간소화)
- [2.4 실전 예제](#24-실전-예제)
- [2.5 마치며](#25-마치며)

### [CHAPTER 3 람다 표현식](#chapter-3-람다-표현식)

- [3.1 람다란 무엇인가?](#31-람다란-무엇인가)
- [3.2 어디에, 어떻게 람다를 사용할까?](#32-어디에-어떻게-람다를-사용할까)
- [3.3 람다 활용 : 실행 어라운드 패턴](#33-람다-활용--실행-어라운드-패턴)
- [3.4 함수형 인터페이스 사용](#34-함수형-인터페이스-사용)
- [3.5 형식 검사, 형식 추론, 제약](#35-형식-검사-형식-추론-제약)
- [3.6 메서드 참조](#36-메서드-참조)
- [3.7 람다, 메서드 참조 활용하기](#37-람다-메서드-참조-활용하기)
- [3.8 람다 표현식을 조합할 수 있는 유용한 메서드](#38-람다-표현식을-조합할-수-있는-유용한-메서드)
- [3.9 비슷한 수학적 개념](#39-비슷한-수학적-개념)
- [3.10 마치며](#310-마치며)

### [PART II 함수형 데이터 처리](#part-ii-함수형-데이터-처리)

### [CHAPTER 4 스트림 소개](#chapter-4-스트림-소개)

- [4.1 스트림이란 무엇인가?](#41-스트림이란-무엇인가)
- [4.2 스트림 시작하기](#42-스트림-시작하기)
- [4.3 스트림과 컬렉션](#43-스트림과-컬렉션)
- [4.4 스트림 연산](#44-스트림-연산)
- [4.5 로드맵](#45-로드맵)
- [4.6 마치며](#46-마치며)

### [CHAPTER 5 스트림 활용](#chapter-5-스트림-활용)

- [5.1 필터링](#51-필터링)
- [5.2 스트림 슬라이싱](#52-스트림-슬라이싱)
- [5.3 매핑](#53-매핑)
- [5.4 검색과 매칭](#54-검색과-매칭)
- [5.5 리듀싱](#55-리듀싱)
- [5.6 실전 연습](#56-실전-연습)
- [5.7 숫자형 스트림](#57-숫자형-스트림)
- [5.8 스트림 만들기](#58-스트림-만들기)
- [5.9 마치며](#59-마치며)

### [CHAPTER 6 스트림으로 데이터 수집](#chapter-6-스트림으로-데이터-수집)

- [6.1 컬렉터란 무엇인가?](#61-컬렉터란-무엇인가)
- [6.2 리듀싱과 요약](#62-리듀싱과-요약)
- [6.3 그룹화](#63-그룹화)
- [6.4 분할](#64-분할)
- [6.5 Collector 인터페이스](#65-collector-인터페이스)
- [6.6 커스텀 컬렉터를 구현해서 성능 개선하기](#66-커스텀-컬렉터를-구현해서-성능-개선하기)
- [6.7 마치며](#67-마치며)

### [CHAPTER 7 병렬 데이터 처리와 성능](#chapter-7-병렬-데이터-처리와-성능)

- [7.1 병렬 스트림](#71-병렬-스트림)
- [7.2 포크/조인 프레임워크](#72-포크조인-프레임워크)
- [7.3 Spliterator 인터페이스](#73-spliterator-인터페이스)
- [7.4 마치며](#74-마치며)

## PART I 기초

### CHAPTER 1 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

#### 1.1 역사의 흐름은 무엇인가?
```text
자바 8 등장 이전에는 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋다고 누군가 조언했을것이다.
하지만, 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.
```

###### GPT 부연 설명
Java 8 이전에는 멀티스레딩을 통해 CPU 자원을 효율적으로 활용하려는 방법이 일반적이었지만, 이 접근법은 다음과 같은 단점이 있었습니다:

### 1. **스레드 관리의 복잡성**
- 스레드를 직접 생성하고 관리하려면 개발자가 동기화 문제, 데드락, 레이스 컨디션 등을 직접 처리해야 합니다.
- 특히, 복잡한 애플리케이션에서 이런 문제들은 디버깅과 유지보수를 어렵게 만듭니다.

### 2. **자원 소모**
- 스레드 하나를 생성하는 데는 상당한 메모리 오버헤드가 필요합니다. 많은 스레드를 생성하면 성능 저하로 이어질 수 있습니다.
- 스레드 풀과 같은 기법으로 이를 완화할 수 있지만, 여전히 제한이 있습니다.

### 3. **병렬 처리 코드의 가독성과 유지보수성**
- 스레드를 활용한 병렬 처리는 코드가 난해하고 읽기 어렵게 되는 경우가 많습니다. 이는 장기적으로 유지보수 비용을 높입니다.

---

### Java 8 이후의 변화
Java 8에서 **Stream API**와 **Fork/Join Framework**(자바 7부터 도입되었지만 8에서 Stream과 결합)가 도입되면서 멀티코어 활용이 훨씬 더 쉬워졌습니다. 특히, **병렬 스트림(Parallel Stream)**과 같은 기능 덕분에 개발자는 간단한 API 호출만으로 멀티스레딩을 활용할 수 있게 되었습니다.

예를 들어:
```java
List<String> list = Arrays.asList("a", "b", "c", "d");
list.parallelStream()
    .forEach(System.out::println);
```
이 코드는 멀티코어를 자동으로 활용합니다. 복잡한 스레드 관리를 개발자가 신경 쓸 필요 없이 간결하게 병렬 처리를 구현할 수 있습니다.

---

### 결론
스레드는 강력한 도구이지만, 직접 사용하면 위험성과 복잡성이 증가합니다. Java 8 이후의 **함수형 프로그래밍**과 **병렬 처리 API**는 스레드 관리의 어려움을 크게 완화시키고, 더 안정적이고 유지보수 가능한 코드를 작성할 수 있도록 도와줍니다. 

따라서 Java 8 이전에는 스레드 활용이 일반적이었다는 점은 맞지만, 현대적인 자바 개발에서는 가급적 **고수준 API**(예: Stream, CompletableFuture)를 사용하는 것이 권장됩니다.

#### 1.2 왜 아직도 자바는 변화하는가?

#### 1.3 자바 함수

#### 1.4 스트림

#### 1.5 디폴트 메서드와 자바 모듈

#### 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

#### 1.7 마치며

### CHAPTER 2 동작 파라미터화 코드 전달하기

#### 2.1 변화하는 요구사항에 대응하기

#### 2.2 동작 파라미터화

#### 2.3 복잡한 과정 간소화

#### 2.4 실전 예제

#### 2.5 마치며

### CHAPTER 3 람다 표현식

#### 3.1 람다란 무엇인가?

#### 3.2 어디에, 어떻게 람다를 사용할까?

#### 3.3 람다 활용 : 실행 어라운드 패턴

#### 3.4 함수형 인터페이스 사용

#### 3.5 형식 검사, 형식 추론, 제약

#### 3.6 메서드 참조

#### 3.7 람다, 메서드 참조 활용하기

#### 3.8 람다 표현식을 조합할 수 있는 유용한 메서드

#### 3.9 비슷한 수학적 개념

#### 3.10 마치며

## PART II 함수형 데이터 처리

### CHAPTER 4 스트림 소개

#### 4.1 스트림이란 무엇인가?

#### 4.2 스트림 시작하기

#### 4.3 스트림과 컬렉션

#### 4.4 스트림 연산

#### 4.5 로드맵

#### 4.6 마치며

### CHAPTER 5 스트림 활용

#### 5.1 필터링

#### 5.2 스트림 슬라이싱

#### 5.3 매핑

#### 5.4 검색과 매칭

#### 5.5 리듀싱

#### 5.6 실전 연습

#### 5.7 숫자형 스트림

#### 5.8 스트림 만들기

#### 5.9 마치며

### CHAPTER 6 스트림으로 데이터 수집

#### 6.1 컬렉터란 무엇인가?

#### 6.2 리듀싱과 요약

#### 6.3 그룹화

#### 6.4 분할

#### 6.5 Collector 인터페이스

#### 6.6 커스텀 컬렉터를 구현해서 성능 개선하기

#### 6.7 마치며

### CHAPTER 7 병렬 데이터 처리와 성능

#### 7.1 병렬 스트림

#### 7.2 포크/조인 프레임워크

#### 7.3 Spliterator 인터페이스

#### 7.4 마치며
