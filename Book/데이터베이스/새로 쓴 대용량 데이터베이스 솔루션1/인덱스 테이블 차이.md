### **인덱스 일체형 테이블과 인덱스 분리형 테이블**

데이터베이스에서는 **데이터와 인덱스가 저장되는 방식**에 따라 **인덱스 일체형 테이블**(Clustered Index Table)과 **인덱스 분리형 테이블**(Heap Table)로 구분할 수 있습니다.

---

## **1. 인덱스 일체형 테이블 (Clustered Index Table)**
**: 기본 키(Primary Key) 인덱스를 기준으로 데이터가 정렬되어 저장되는 테이블**  
MySQL의 **InnoDB**, SQL Server의 **Clustered Index**가 대표적입니다.

### **특징**
- **데이터 자체가 클러스터형(Clustered) 인덱스로 저장됨**  
  → 즉, 인덱스가 곧 데이터의 물리적 저장 순서를 결정함.
- **프라이머리 키(Primary Key) 인덱스가 자동으로 클러스터 인덱스가 됨**  
  → 기본 키를 기준으로 데이터를 정렬하며, 기본 키가 없으면 DBMS가 내부적으로 유사한 구조를 생성함.
- **인덱스 리프 노드가 실제 데이터 페이지를 가리킴**  
  → Secondary Index(보조 인덱스)는 클러스터 인덱스의 키 값을 참조.

### **장점**
- **Primary Key 기반 검색이 빠름**  
  → 데이터가 정렬되어 있기 때문에 범위 조회(Range Scan)나 정렬 작업이 효율적.
- **인덱스와 데이터가 한곳에 저장되어 I/O 비용 절감**  
  → 인덱스를 통해 데이터 페이지를 찾을 필요가 없음.

### **단점**
- **Insert/Update/Delete가 비효율적일 수 있음**  
  → 기존 데이터 사이에 새로운 데이터를 삽입해야 하면 **페이지 분할(Page Split)** 이 발생할 수 있음.
- **Secondary Index(보조 인덱스)의 탐색 비용이 증가**  
  → 보조 인덱스는 클러스터 인덱스의 키 값을 참조하므로, 인덱스를 두 번 거쳐야 데이터를 찾을 수 있음.

---

## **2. 인덱스 분리형 테이블 (Heap Table)**
**: 데이터가 특정한 순서 없이 저장되는 테이블**  
MySQL의 **MyISAM**, PostgreSQL, Oracle의 일반 테이블이 대표적입니다.

### **특징**
- **데이터가 특정한 정렬 없이 저장됨**  
  → Insert되는 순서대로 데이터를 저장하므로, **특정 컬럼을 기준으로 정렬되지 않음**.
- **별도의 클러스터 인덱스 없음**  
  → Primary Key를 생성해도 클러스터 인덱스로 정렬되지 않음.
- **인덱스 리프 노드가 데이터의 물리적 위치(Row ID)를 가리킴**  
  → 보조 인덱스는 레코드의 주소(Row ID)를 직접 저장하여 데이터를 찾아감.

### **장점**
- **Insert 속도가 빠름**  
  → 데이터를 정렬할 필요가 없으므로, 새로운 데이터를 추가하는 과정에서 페이지 분할이 발생하지 않음.
- **Secondary Index(보조 인덱스) 탐색 비용이 일정함**  
  → 보조 인덱스가 데이터를 바로 가리키므로, 클러스터 인덱스처럼 추가적인 탐색이 필요 없음.

### **단점**
- **Primary Key 기반 검색 속도가 느림**  
  → 인덱스를 통해 데이터를 찾고, 다시 데이터 페이지에서 읽어야 하기 때문에 I/O 비용이 높음.
- **정렬 작업이 비효율적**  
  → 데이터를 정렬하려면 추가적인 정렬 연산(Sort Operation)이 필요.

---

## **3. 비교 요약**

|  구분  | **인덱스 일체형 테이블 (Clustered Index Table)** | **인덱스 분리형 테이블 (Heap Table)** |
|--------|--------------------------------------|--------------------------------|
| **데이터 저장 방식** | Primary Key 기준으로 정렬됨 | 삽입된 순서대로 저장됨 |
| **Primary Key 인덱스** | 클러스터 인덱스로 저장됨 | 별도로 저장됨 |
| **데이터 탐색** | Primary Key 검색이 빠름 | 인덱스를 통해 Row ID를 찾아야 함 |
| **보조 인덱스 조회** | 클러스터 인덱스를 한 번 더 거쳐야 함 | 데이터 위치를 바로 찾을 수 있음 |
| **INSERT 속도** | 페이지 분할 가능성 있음(느릴 수 있음) | 빠름 |
| **DELETE 속도** | 페이지 단편화 발생 가능 | 빠름 |
| **정렬된 검색** | 빠름 | 느림 |

---

## **4. 어떤 경우에 사용해야 할까?**
- **인덱스 일체형 테이블 (Clustered Index Table)**
  - **범위 검색이 많거나 Primary Key 조회가 많을 때**
  - **정렬된 데이터 처리가 중요할 때 (e.g. 시간순 정렬, 데이터 분석)**
  - **읽기 성능이 중요한 경우 (읽기 최적화가 필요할 때)**

- **인덱스 분리형 테이블 (Heap Table)**
  - **삽입/삭제 작업이 많을 때 (e.g. 로그 테이블, 임시 데이터)**
  - **특정 키 기반 조회보다 전체 데이터를 빠르게 Insert해야 할 때**
  - **데이터 정렬이 필요하지 않을 때**

---

## **5. MySQL, PostgreSQL에서의 차이점**
- **MySQL**
  - InnoDB → **클러스터 인덱스 기반 테이블 (Clustered Index Table)**
  - MyISAM → **인덱스 분리형 테이블 (Heap Table)**
- **PostgreSQL**
  - 기본 테이블은 Heap Table(인덱스 분리형 테이블)
  - `CLUSTER` 명령을 사용하면 특정 인덱스를 기준으로 데이터 재정렬 가능하지만 자동으로 유지되지는 않음.

---

### **결론**
- 인덱스 일체형 테이블(Clustered Index Table)은 **읽기 성능과 정렬된 검색**이 중요한 경우 유리하고,  
- 인덱스 분리형 테이블(Heap Table)은 **삽입/삭제가 많고 정렬이 필요하지 않은 경우** 유리합니다.

사용 목적에 맞게 적절한 테이블 구조를 선택하는 것이 중요합니다! 🚀
