## 목차

### [1. 클래스와 데이터](#1-클래스와-데이터)

- [1.1 프로젝트 환경 구성](#11-프로젝트-환경-구성)
- [1.2 클래스가 필요한 이유](#12-클래스가-필요한-이유)
- [1.3 클래스 도입](#13-클래스-도입)
- [1.4 객체 사용](#14-객체-사용)
- [1.5 클래스, 객체, 인스턴스 정리](#15-클래스-객체-인스턴스-정리)
- [1.6 배열 도입 - 시작](#16-배열-도입-시작)
- [1.7 배열 도입 - 리펙토링](#17-배열-도입-리펙토링)
- [1.8 문제와 풀이](#18-문제와-풀이)
- [1.9 정리](#19-정리)

### [2. 기본형과 참조형](#2-기본형과-참조형)

- [2.1 기본형 vs 참조형1 - 시작](#21-기본형-vs-참조형1-시작)
- [2.2 기본형 vs 참조형2 - 변수 대입](#22-기본형-vs-참조형2-변수-대입)
- [2.3 기본형 vs 참조형3 - 메서드 호출](#23-기본형-vs-참조형3-메서드-호출)
- [2.4 참조형과 메서드 호출 - 활용](#24-참조형과-메서드-호출-활용)
- [2.5 변수와 초기화](#25-변수와-초기화)
- [2.6 null](#26-null)
- [2.7 NullPointerException](#27-nullpointerexception)
- [2.8 문제와 풀이](#28-문제와-풀이)
- [2.9 정리](#29-정리)

### [3. 객체 지향 프로그래밍](#3-객체-지향-프로그래밍)

- [3.1 절차 지향 프로그래밍1 - 시작](#31-절차-지향-프로그래밍1-시작)
- [3.2 절차 지향 프로그래밍2 - 데이터 묶음](#32-절차-지향-프로그래밍2-데이터-묶음)
- [3.3 절차 지향 프로그래밍3 - 메서드 추출](#33-절차-지향-프로그래밍3-메서드-추출)
- [3.4 클래스와 메서드](#34-클래스와-메서드)
- [3.5 객체 지향 프로그래밍](#35-객체-지향-프로그래밍)
- [3.6 문제와 풀이](#36-문제와-풀이)
- [3.7 정리](#37-정리)

### [4. 생성자](#4-생성자)

- [4.1 생성자 - 필요한 이유](#41-생성자-필요한-이유)
- [4.2 this](#42-this)
- [4.3 생성자 - 도입](#43-생성자-도입)
- [4.4 기본 생성자](#44-기본-생성자)
- [4.5 생성자 - 오버로딩과 this()](#45-생성자-오버로딩과-this)
- [4.6 문제와 풀이](#46-문제와-풀이)
- [4.7 정리](#47-정리)

### [5. 패키지](#5-패키지)

- [5.1 패키지 - 시작](#51-패키지-시작)
- [5.2 패키지 - import](#52-패키지-import)
- [5.3 패키지 규칙](#53-패키지-규칙)
- [5.4 패키지 활용](#54-패키지-활용)
- [5.5 정리](#55-정리)

### [6. 접근 제어자](#6-접근-제어자)

- [6.1 접근 제어자 이해1](#61-접근-제어자-이해1)
- [6.2 접근 제어자 이해2](#62-접근-제어자-이해2)
- [6.3 접근 제어자 종류](#63-접근-제어자-종류)
- [6.4 접근 제어자 사용 - 필드, 메서드](#64-접근-제어자-사용-필드-메서드)
- [6.5 접근 제어자 사용 - 클래스 레벨](#65-접근-제어자-사용-클래스-레벨)
- [6.6 캡슐화](#66-캡슐화)
- [6.7 문제와 풀이](#67-문제와-풀이)
- [6.8 정리](#68-정리)

## 1. 클래스와 데이터

### 1.1 프로젝트 환경 구성

### 1.2 클래스가 필요한 이유

### 1.3 클래스 도입

### 1.4 객체 사용

### 1.5 클래스, 객체, 인스턴스 정리

- 클래스 : 객체를 생성하기 위한 '틀'
- 객체 : 클래스에서 정의한 속성과 기능을 가진 실체
- 인스턴스 : 특정 클래스로부터 생성된 객체
- 객체 vs 인스턴스 : 둘 다 클래스에서 나온 실체라는 의미에서 비슷하지만, 인스턴스는 객체보다 좀 더 관계에 초점을 맞춘 단어이다.
- `student1`은 `Student`의 인스턴스다.
- 보통 둘을 구분하지 않고 사용한다.

### 1.6 배열 도입 - 시작

- null은 참조값이 없다는 뜻이다.
- `자바에서 대입은 항상 변수에 들어 있는 값을 읽고 복사한다는 의미이다.`

### 1.7 배열 도입 - 리펙토링

- 향상된 for문

### 1.8 문제와 풀이

### 1.9 정리

- 사용자 정의 타입은 클래스(설계도)가 필요하다.

## 2. 기본형과 참조형

### 2.1 기본형 vs 참조형1 - 시작

### 2.2 기본형 vs 참조형2 - 변수 대입

- 참조형 : 건물의 주소가 복사된다는 개념
- 값을 대입한다는 개념이 아니다. 복사해서 전달하는 것이다.

### 2.3 기본형 vs 참조형3 - 메서드 호출

```java
changeReference(Data dataX) {
   dataX.value = 20;
} //Data내부의 값을 변경하고 싶다면
```

### 2.4 참조형과 메서드 호출 - 활용

```java
static void initStudent(Student student, String name, int age, int grade) {
    student.name = name
    student.age = age;
    student.grade = grade;
}

>>> 더 발전된 방법

static Student createStudent(String name, int age, int grade) {
    Student student = new Student();
    student.name = name
    student.age = age;
    student.grade = grade;
    return student;
}

```

### 2.5 변수와 초기화

- 메서드 안, 매개변수 : 지역변수
- 멤버변수는 자동 초기화 된다. 지역변수는 수동으로 초기화 된다.
- null은 참조할 대상이 없다는 뜻

### 2.6 null

- 가리키는 대상이 없거나 나중에 대상을 지정하고 싶을때
- 아무도 참조하지 않는 인스턴스는 GC의 처리 대상이 된다. 자바의 큰 장점이라 할 수 있다.

### 2.7 NullPointerException

### 2.8 문제와 풀이

### 2.9 정리

## 3. 객체 지향 프로그래밍

### 3.1 절차 지향 프로그래밍1 - 시작

### 3.2 절차 지향 프로그래밍2 - 데이터 묶음

### 3.3 절차 지향 프로그래밍3 - 메서드 추출

- 데이터와 기능이 분리되어 있다는 한계가 있다.
- 우리가 사용하는 데이터와 기능은 밀접하게 연관되어 있다.

### 3.4 클래스와 메서드

### 3.5 객체 지향 프로그래밍

- 자신의 속성을 바꾼다.
- 속성과 기능이 하나의 클래스에 존재한다.

### 3.6 문제와 풀이

### 3.7 정리

## 4. 생성자

### 4.1 생성자 - 필요한 이유

### 4.2 this

### 4.3 생성자 - 도입

### 4.4 기본 생성자

### 4.5 생성자 - 오버로딩과 this()

### 4.6 문제와 풀이

### 4.7 정리

## 5. 패키지

### 5.1 패키지 - 시작

### 5.2 패키지 - import

### 5.3 패키지 규칙

### 5.4 패키지 활용

### 5.5 정리

## 6. 접근 제어자

### 6.1 접근 제어자 이해1

### 6.2 접근 제어자 이해2

### 6.3 접근 제어자 종류

### 6.4 접근 제어자 사용 - 필드, 메서드

### 6.5 접근 제어자 사용 - 클래스 레벨

### 6.6 캡슐화
- 외부접근을 제어. 데이터를 숨겨라, 기능을 숨겨라.
- 모든 기능이 아닌 필요한 기능만 오픈을 한다.
- 마치 자동차에서 사용자는 핸들, 카시트, 조작버튼을 보고 내부의 세세한 시스템은 못보는것과 마찬가지.
- 객체의 데이터는 메서드를 통해 접근해야 한다.

### 6.7 문제와 풀이

### 6.8 정리
